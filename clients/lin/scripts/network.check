#!/usr/bin/env python

# net_checks.py - module containing some network checks for h2gc **Linux** client
#
# Status: So new.
#
# Preconditions: should be in scripts directory of h2gc client system
# Postconditions: 
#     Returns 0 on no error, 1-100 on problem found, by severity.  
#     Error notes > .sad, Log >> .log
#

import os
import subprocess
import re
import StringIO
import json
import urllib2

class Status:
    def __init__(self):
        self.overall = 0  
        self.sad = "Internet looks good.  Guess that's something."
    def __str__(self):
        return ("Overall Status: " + str(self.overall) + "\n"
                "Current Evaluation of Issues: " + str(self.sad) + "\n")

class NetworkDevice:
    def __init__(self):
        self.foo = "bar"
    def __str__(self):        
        return ("Network Device Stuff\n")	

# bash_wrapper - run a bash command 
#
def bash_wrapper(full_executable_path):
    print "Running: " + str(full_executable_path)
    my_environment = os.environ.copy()
    p1 = subprocess.Popen(full_executable_path.split(), env=my_environment, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out,err = p1.communicate()
    returncode = p1.returncode
    print "stdout: ", out
    print "stderr: ", err
    print "returncode: ", returncode
    return returncode

# lifted byzantium config code to get wifi int data to see how I like it
# GPL v3 just like my stuff
#
def get_wifi_config_byzantium():
    wireless = []
    # Enumerate all network interfaces and pick out only the wireless ones.
    # Ignore the rest.
    interfaces = os.listdir('/sys/class/net')

    # Remove the loopback interface because that's our failure case.
    if 'lo' in interfaces:
        interfaces.remove('lo')
    if not interfaces:
        print "ERROR: No wireless interfaces found.  Terminating."
        sys.exit(1)

    # For each network interface's pseudofile in /sys, test to see if a
    # subdirectory 'wireless/' exists.  Use this to sort the list of
    # interfaces into wired and wireless.
    for i in interfaces:
        if os.path.isdir("/sys/class/net/%s/wireless" % i):
            wireless.append(i)

    print "wifi interfaces: " + str(len(wireless))
    if len(wireless):
        # Capture the interface's current settings.
        command = ['/sbin/iwconfig', interface]
        configuration = ''
        output = subprocess.Popen(command, stdout=subprocess.PIPE).stdout
        configuration = output.readlines()

        # Test the interface's current configuration.  Go back to the top of
        # the configuration loop and try again if it's not what we expect.
        Mode = False
        Essid = False
        Bssid = False
        Frequency = False
        for line in configuration:
            # Ad-hoc mode?
            modematch = re.search('Mode:([\w-]+)', line)
            if modematch and modematch.group(1) == 'Ad-Hoc':
                print "Mode is correct."
                Mode = True

            # Correct ESSID?
            essidmatch = re.search('ESSID:"([\w]+)"', line)
            if essidmatch and essidmatch.group(1) == essid:
                print "ESSID is correct."
                Essid = True

            # Correct BSSID?
            bssidmatch = re.search('Cell: (([\dA-F][\dA-F]:){5}[\dA-F][\dA-F])', line)
            if bssidmatch and bssidmatch.group(1) == bssid:
                print "BSSID is correct."
                Bssid = True

            # Correct frequency (because iwconfig doesn't report channels)?
            freqmatch = re.search('Frequency:([\d.]+)', line)
            if freqmatch and freqmatch.group(1) == frequency:
                print "Channel is correct."
                Frequency = True

            print "Mode, Essid, Bssid, Freq:" + modematch + essidmatch + bssidmatch + freqmatch 
        else:
            print "no wifi stuff"

# Check the status of network devices
#
# modifies: network list
#
def check_network_status(network_list):
    # Guesstimate method for doing this
        # Resolve the default gateway
        # Get data on the interface used for the intertubes
        # Get data on the interface used for local stuff
        # Evaluate:
        #     Check to see if the number and use of interfaces make sense.
        #     Does it make sense?
        #     Are we doing o.k. with the intertubes?
        #     Are we doing o.k. with local stuff?
        # If any of those are not a yes, debug
 
    # Some testing stuff      
    
    get_wifi_config_byzantium()
    # Check out our routing table
    routecmd = "route -n"
    # Enumerate network devices
    ifcmd = "ifconfig"
    # See what's associted with what
    iwlstcmd = "iwlist scan"
    # Check well known internet sites
    # seems slow - this mtr for five packets takes about 20 seconds on my laptop
    mtrcmd = "mtr -r -c 5 www.google.com"
    # Check download speeds
    wgetcmd = "wget -O /dev/null - http://cachefly.cachefly.net/10mb.test"

    bash_wrapper(routecmd)
    bash_wrapper(ifcmd)
    bash_wrapper(iwlstcmd)
    bash_wrapper(mtrcmd)
    bash_wrapper(wgetcmd)
    result = 0

# Log the analysis of net devices to local log file
#
# modifies: status object
#
def log_network_data(net_ob_list, status):
    result = 0
    # Code to calculate simplified overall result goes here
    status.overall += result

# 
# main
#
def main():
    status=Status()
    network_list=[] 
    config_dir = os.path.expanduser("~") + "/.h2gc/scripts/"

    config_file = "network.conf"
    full_config_path = config_dir + config_file
    sad_file = "network.sad"
    full_sad_path = config_dir + sad_file
 
    check_network_status(network_list)
    log_network_data(network_list, status) 
 
    # Nothing should change the status after this point
    # Write overall status to file, blowing away other contents
    #
    sad_handle = open(full_sad_path, 'w+')    
    sad_handle.write(str(status.sad))
    sad_handle.close()

    return status.overall

if __name__ == '__main__':
    main()
